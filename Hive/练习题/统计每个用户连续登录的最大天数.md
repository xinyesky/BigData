### 统计每个用户连续登录的最大天数

数据源文件如下所示, 请建立Hive表, 并将文件数据加载进表中, 根据需求, 写对应的HQL语句

- 字段解释: 用户ID ,登录日期

~~~properties
1,2019-08-01
1,2019-08-02
1,2019-08-03
2,2019-08-01
2,2019-08-02
3,2019-08-01
3,2019-08-03
4,2019-07-28
4,2019-07-29
4,2019-08-01
4,2019-08-02
4,2019-08-03
~~~

- 建表

~~~sql
create table user(
	id int,
	date string
)row format delimited
fields terminated by ','
~~~

- 加载数据

~~~sql
load data local inpath '/export/data/hive_exercise/user.txt' into table user;
~~~

- 需求: 统计每个用户连续登录的最大天数

~~~properties
# 需求解析
需求求的是连续登录的最大天数, 而连续登录给了我们一个条件, 就是,
如果两个日期是连续登录的, 那么后一条记录的日期减一 等于前一条记录的日期
这个条件扩展开来就是, 如果连续三天登录, 那么 第三条记录日期-2 等于 第二条记录日期-1 等于 第一条记录日期
因为,这个需求的解答思路就出来了, 将 当前用户的当前日期- 该日期的排名 
1. 将日期相同的当天一组, 并记录行数
2. 根据id分组, 日期分组, 取出相同日期的最大值

#举例
#原始数据
4,2019-07-28
4,2019-07-29
4,2019-08-01
4,2019-08-02
4,2019-08-03

#对数据进行排名
4 2019-07-28 1
4 2019-07-29 2
4 2019-08-01 3
4 2019-08-02 4
4 2019-08-03 5

#对每个日期进行sub操作
4 2019-07-27 1
4 2019-07-27 2
4 2019-07-28 3
4 2019-07-28 4
4 2019-07-28 5

# 这时我们就可以根据id,和修改后的日期进行分组, 聚合,并取出最大值, 就是连续登录的最大天数
~~~

- 涉及知识
  - row_number: 根据顺序进行计算
  - rank 排序相同会重复, 数值会跳跃
  - dense_rank 排序相同会重复,数值不会跳跃

- 解答

~~~sql
# 子查询
select t2.id,
       max(t2.days)
from (
         select t1.id,
                count(t1.dt) days
         from(
                 select
                     id,
                     date_sub(date,row_number() over (partition by id order by date)) dt
                 from user

             ) t1
         group by t1.id,t1.dt
         ) t2
group by id
~~~



